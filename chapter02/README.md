## 2.1 기본 문법


### 2.1.1 주석

- 자바와 마찬가지로 세가지 주석 지원. 코드를 문서화할 때 사용함.
- 한 줄 짜리 주석 : // 로 시작하며 줄이 끝나면 주석이 끝남.
- 여러 줄 주석 : /* 로 시작하고 */ 로 끝남.
- KDoc 여러 줄 주석 : /** 로 시작하고 */ 로 끝남.

### 2.1.2 변수 정의하기

- `val timeInSeconds = 15`
- 정의를 이루는 요소는 다음과 같다.
  - val 키워드 : 값을 뜻하는 value 에서 유래함.
  - 변수 식별자(identifier) : 새 변수에 이름을 부여하고, 나중에 이를 가리킬 때 사용함.
  - 변수의 초기값 정의 : = 기호 뒤에 온다.

### 2.1.4 가변 변수

- 불변 변수 `val`
  - 한번 초기화 하면 다시는 값을 대입할 수 없는 변수. 자바의 final 변수와 비슷함.
  - 함수가 부수 효과를 일으키지 못하고, 함수형 스타일 코드를 장려할 수 있으며, 이로 인해 코드에 대한 추론이 쉬워지기 때문에 가능하면 불변 변수를 많이 사용해야 함.
- 가변 변수 `var`
  - 기본적인 문법은 불변 변수의 경우와 같으며 원할 때 변수 값을 얼마든지 바꿀 수 있다.
  - 처음 변수에 값을 대입할 때 추론된 변수 타입은 변수가 불변이든 그렇지 않든 계속 유지된다.

### 2.1.5 식과 연산자

- 코틀린 식은 다음과 같이 분류할 수 있다.
  - 각 타입에 속하는 구체적인 값을 표현하는 리터럴(12, 3.56)
  - 변수 / 프로퍼티 참조와 함수 호출(a.readLine(), "abc", .length, "12", toInt())
  - 전위와 후위 단항 연산(-a, ++b, c--)
  - 이항 연산(a+b, 2*3, x<1) <br></br><br></br>

## 2.2 기본 타입


코틀린은 똑같은 타입이 문맥에 따라 원시 타입과 참조 타입을 가리키기 때문에 구분이 모호하다. 
자바에는 원시 타입을 감싸는 박싱 타입(boxing type)이 있지만, 코틀린은 필요할 때 암시적으로 박싱을 수행한다.
- 자바와 달리 모든 코틀린 타입은 클래스 정의를 기반으로 만들어 진다.
- `Int`와 같이 원시 타입과 비슷한 타입들도 메서드와 프로퍼티를 제공한다.
- 예를 들어 `1.5.toInt()` 라는 식으로 1.5에 대해 Double 타입에 정의된 toInt() 메서드를 호출할 수 있다. <br></br>

### 2.2.1 정수 타입

- `Byte` : 1 바이트, -128 ~ 127, 자바의 Byte 타입에 대응됨.
- `Short` : 2 바이트, -32768 ~ 32767, 자바의 Short 타입에 대응됨.
- `Int` : 4 바이트, -2^31 ~ 2^31 - 1, 자바의 Int 타입에 대응됨.
- `Long` : 8 바이트, -2^63 ~ 2^63 - 1, 자바의 Long 타입에 대응됨.<br></br>
- 리터럴에 `_` 를 넣어서 가독성을 높일 수 있다.
- 리터럴 자체의 타입은 그 수를 2진수로 표현했을 때의 크기에 따라 `Int` 일 수 도 있고 `Long` 일 수도 있다.
- 범위만 맞으면 리터럴을 크기가 더 작은 타입의 변수에 대입해도 된다.
- 각 정수 타입에는 최솟값(MIN_VALUE)과 최댓값(MAX_VALUE)을 포함하는 상수 정의가 들어있다.

### 2.2.2 부동소수점 수

- 자바와 마찬가지로 `Float`와 `Double`를 제공한다.
- 부동소수점 수 리터럴 중 가장 단순한 형태는 10진 소수 형태이다.
- 정수 부분이 비어있는 경우 정수 부분을 0으로 간주한다.
- 과학적 표기법(scientific notation) 리터럴을 허용한다. 
- `e`나 `E`뒤에 10을 몇 번 거듭제곱하는지 숫자로 표기한다.

### 2.2.4 비트 연산

`Int` 와 `Long` 은 비트 수준의 연산을 지원한다.
- `shl` : 왼쪽 시프트
- `shr` : 오른쪽 시프트
- `ushr` : 부호 없는 오른쪽 시프트
- `and` : 비트 곱 (AND)
- `or` : 비트 합 (OR)
- `xor` : 비트 배타합 (XOR)
- `inv` : 비트 반전 (inversion), 이항 연산이나 단항 연산이 아닌 메서드.

### 2.2.6 수 변환

- 각 수 타입마다 값을 다른 수 타입으로 변환하는 연산이 정의되어 있다.
- toChar(), toByte(), toShort(), toInt(), toLong(), toFloat(), toDouble() 등이 있다. 
- 자바와 달리 코틀린에서는 범위가 큰 타입이 사용돼야 하는 문맥에 범위가 작은 타입을 사용할 수 없다.
  - 예를 들어, Int 값을 Long 변수에 대입할 수 없다.

### 2.2.7 불 타입과 논리 연산

- ! : 논리 부정
- or, and, xor : 즉시 계산 방식의 논리합, 논리곱, 논리배타합
- ||, && : 지연 계산 방식의 논리합, 논리곱
  - || : 왼쪽 피연산자가 참이면 오른쪽 피연산자를 계산하지 않음
  - && : 왼쪽 피연산자가 거짓이면 왼쪽 피연산자를 계산하지 않음

### 2.2.8 비교와 동등성

- == (같다), != (같지 않다), < (~보다 작다), <= (~보다 작거나 같다), > (~보다 크다), >= (~보다 크거나 같다)
- 일반적으로 동등성 연산인 `==`와 `!=` 를 모든 타입의 값에 적용할 수 있고 두 인자가 같은 타입이어야 한다.
  - 코틀린은 박싱이 암시적으로 진행되기 때문에 타입 사이의 동등성 연산을 허용하면 혼란을 야기할 수 있기 때문.
- 수 타입, Char, Boolean 의 경우 예외가 있다.
  - 모든 수 타입은 서로 비교 연산자를 사용할 수 있다. 
  - 수 타입 사이의 산술 연산이 가능한 모든 경우를 다룰 수 있도록 오버로딩 된 것과 마찬가지이다.
  - Char, Boolean 값도 비교 연산이 가능하다. 하지만 같은 타입의 값과만 비교할 수 있다.
  - false 는 true 보다 작다고 가정하고, Char 는 문자 코드 값에 따라 비교된다.
  - 자바의 경우 불 타입의 대소 관계가 존재하지 않기 때문에 동등성 비교만 적용할 수 있다.
  - NaN 은 그 어떤 값과도 같지 않다. 특히 다른 NaN 과도 같지 않고, 무한대를 포함한 다른 어떤 값보다 작지도 크지도 않다.